// Description:
//   Auth allows you to assign roles to users which can be used by other scripts
//   to restrict access to Hubot commands
//
// Dependencies:
//   None
//
// Configuration:
//   HUBOT_AUTH_ADMIN - A comma separate list of user IDs
//
// Commands:
//   hubot <user> has <role> role - Assigns a role to a user
//   hubot <user> doesn't have <role> role - Removes a role from a user
//   hubot what role does <user> have - Find out what roles are assigned to a specific user
//   hubot who has admin role - Find out who's an admin and can assign roles
//
// Notes:
//   * Call the method: robot.auth.hasRole(msg.envelope.user,'<role>')
//   * returns bool true or false
//
//   * the 'admin' role can only be assigned through the environment variable
//   * roles are all transformed to lower case
//
//   * The script assumes that user IDs will be unique on the service end as to
//     correctly identify a user. Names were insecure as a user could impersonate
//     a user
//
// Author:
//   alexwilliamsca, tombell

// Generated by CoffeeScript 1.6.3
(function() {
  var __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  module.exports = function(robot) {
    var Auth, admins;
    if (process.env.HUBOT_AUTH_ADMIN == null) {
      robot.logger.warning('The HUBOT_AUTH_ADMIN environment variable not set');
    }
    if (process.env.HUBOT_AUTH_ADMIN != null) {
      admins = process.env.HUBOT_AUTH_ADMIN.split(',');
    } else {
      admins = [];
    }
    Auth = (function() {
      function Auth() {}

      Auth.prototype.hasRole = function(user, roles) {
        var role, _i, _len, _ref;
        if (_ref = user.id.toString(), __indexOf.call(admins, _ref) >= 0) {
          return true;
        }
        if (typeof roles === 'string') {
          roles = [roles];
        }
        user = robot.brain.userForId(user.id);
        if ((user != null) && (user.roles != null)) {
          for (_i = 0, _len = roles.length; _i < _len; _i++) {
            role = roles[_i];
            if (__indexOf.call(user.roles, role) >= 0) {
              return true;
            }
          }
        }
        return false;
      };

      return Auth;

    })();
    robot.auth = new Auth;
    robot.respond(/@?(.+) (has) (["'\w: -_]+) (role)/i, function(msg) {
      var myRoles, name, newRole, user, _ref, _ref1;
      name = msg.match[1].trim();
      newRole = msg.match[3].trim().toLowerCase();
      if ((_ref = name.toLowerCase()) !== '' && _ref !== 'who' && _ref !== 'what' && _ref !== 'where' && _ref !== 'when' && _ref !== 'why') {
        user = robot.brain.userForName(name);
        if (user == null) {
          return msg.reply("" + name + " does not exist");
        }
        user.roles || (user.roles = []);
        if (__indexOf.call(user.roles, newRole) >= 0) {
          return msg.reply("" + name + " already has the '" + newRole + "' role.");
        } else {
          if (newRole === 'admin') {
            return msg.reply("Sorry, the 'admin' role can only be defined in the HUBOT_AUTH_ADMIN env variable.");
          } else {
            myRoles = msg.message.user.roles || [];
            if (_ref1 = msg.message.user.id.toString(), __indexOf.call(admins, _ref1) >= 0) {
              user.roles.push(newRole);
              return msg.reply("Ok, " + name + " has the '" + newRole + "' role.");
            } else {
              return msg.reply("Only " + admins + " can assign roles. You're " + msg.message.user.id);
            }
          }
        }
      }
    });
    robot.respond(/@?(.+) (doesn't have|does not have) (["'\w: -_]+) (role)/i, function(msg) {
      var myRoles, name, newRole, role, user, _ref, _ref1;
      name = msg.match[1].trim();
      newRole = msg.match[3].trim().toLowerCase();
      if ((_ref = name.toLowerCase()) !== '' && _ref !== 'who' && _ref !== 'what' && _ref !== 'where' && _ref !== 'when' && _ref !== 'why') {
        user = robot.brain.userForName(name);
        if (user == null) {
          return msg.reply("" + name + " does not exist");
        }
        user.roles || (user.roles = []);
        if (newRole === 'admin') {
          return msg.reply("Sorry, the 'admin' role can only be removed from the HUBOT_AUTH_ADMIN env variable.");
        } else {
          myRoles = msg.message.user.roles || [];
          if (_ref1 = msg.message.user.id.toString(), __indexOf.call(admins, _ref1) >= 0) {
            user.roles = (function() {
              var _i, _len, _ref2, _results;
              _ref2 = user.roles;
              _results = [];
              for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
                role = _ref2[_i];
                if (role !== newRole) {
                  _results.push(role);
                }
              }
              return _results;
            })();
            return msg.reply("Ok, " + name + " doesn't have the '" + newRole + "' role.");
          } else {
            return msg.reply("Only admins can assign roles. You're " + msg.message.user.id);
          }
        }
      }
    });
    robot.respond(/(?:what|which) role(s?) does @?(.+) have\?*$/i, function(msg) {
      var name, user, _ref;
      name = msg.match[2].trim();
      user = robot.brain.userForName(name);
      if (user == null) {
        return msg.reply("" + name + " does not exist");
      }
      user.roles || (user.roles = []);
      if (_ref = user.id.toString(), __indexOf.call(admins, _ref) >= 0) {
        return msg.reply("" + user.name + " has admin role and thus has all the roles :all_the_things: ");
      } else if (user.roles.length === 0) {
        return msg.reply("" + user.name + " doesn't have any roles :forever_alone:.");
      } else {
        return msg.reply("" + user.name + " has the following roles: " + (user.roles.join(', ')) + ".");
      }
    });
    return robot.respond(/who has admin role\?*$/i, function(msg) {
      var admin, adminNames, user, _i, _len;
      adminNames = [];
      for (_i = 0, _len = admins.length; _i < _len; _i++) {
        admin = admins[_i];
        user = robot.brain.userForId(admin);
        if (user != null) {
          adminNames.push("" + user.real_name + " (@" + user.name + ")");
        }
      }
      return msg.reply("The following people have the 'admin' role: " + (adminNames.join(', ')));
    });
  };

}).call(this);
